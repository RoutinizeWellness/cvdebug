    cleaned = cleaned.trim();

    const parsed = JSON.parse(cleaned);
    return parsed;

  } catch (error) {
    console.log("[extractJSON] Error during JSON extraction:", error);
    try {
      return JSON.parse(content);
    } catch (err) {
      console.warn("[extractJSON] Fallback json parse failed:", err);
      return null;
    }
  }
}

// ML-based fallback analysis using externalized keywords and templates
export function generateFallbackAnalysis(ocrText: string, jobDescription?: string): any {
  console.log("[Fallback Analysis] Generating ML-based analysis");
  
  const text = ocrText.toLowerCase();
  const hasJD = jobDescription && jobDescription.trim().length > 0;
  const jdLower = hasJD ? jobDescription!.toLowerCase() : "";
  
  // Extract contact information
  const emailMatch = ocrText.match(/[\w.-]+@[\w.-]+\.\w+/);
  const phoneMatch = ocrText.match(/\+?[\d\s()-]{10,}/);
  const hasLinkedIn = text.includes("linkedin") || text.includes("linked.in");
  
  // Enhanced role classification using externalized keywords
  let category: RoleCategory = "General";
  const roleScores: Record<string, number> = {
    "Engineering": 0,
    "Software Engineering": 0,
    "Marketing": 0,
    "Product Management": 0,
    "Data Science": 0,
    "General": 0
  };
  
  // Engineering signals
  if (/(structural|civil|mechanical|electrical)\s*(engineer|engineering)/i.test(text)) roleScores["Engineering"] += 10;
  if (/\b(etabs|sap2000|revit|autocad|staad|tekla|risa)\b/i.test(text)) roleScores["Engineering"] += 8;
  if (/\b(ibc|asce|eurocode|aisc|aci)\b/i.test(text)) roleScores["Engineering"] += 6;
  if (/\b(steel|concrete|seismic|foundation|structural design)\b/i.test(text)) roleScores["Engineering"] += 4;
  
  // Software Engineering signals
  if (/(software|full.?stack|backend|frontend|web)\s*(engineer|developer)/i.test(text)) roleScores["Software Engineering"] += 10;
  if (/\b(javascript|python|java|react|node|typescript|angular|vue)\b/i.test(text)) roleScores["Software Engineering"] += 6;
  if (/\b(api|microservices|docker|kubernetes|aws|git|ci\/cd)\b/i.test(text)) roleScores["Software Engineering"] += 4;
  
  // Marketing signals
  if (/(digital|content|growth|performance)\s*marketing/i.test(text)) roleScores["Marketing"] += 10;
  if (/\b(seo|sem|google analytics|facebook ads|ppc|cpc|ctr)\b/i.test(text)) roleScores["Marketing"] += 6;
  if (/\b(campaign|conversion|roi|lead generation|email marketing)\b/i.test(text)) roleScores["Marketing"] += 4;
  
  // Product Management signals
  if (/product\s*(manager|management|owner)/i.test(text)) roleScores["Product Management"] += 10;
  if (/\b(roadmap|backlog|user stories|sprint|jira|confluence)\b/i.test(text)) roleScores["Product Management"] += 6;
  if (/\b(mvp|okr|kpi|stakeholder|product strategy)\b/i.test(text)) roleScores["Product Management"] += 4;
  
  // Data Science signals
  if (/(data|machine learning|ml)\s*(scientist|engineer|analyst)/i.test(text)) roleScores["Data Science"] += 10;
  if (/\b(python|r|sql|tableau|power bi|pandas|numpy)\b/i.test(text)) roleScores["Data Science"] += 6;
  if (/\b(regression|classification|clustering|predictive|statistical)\b/i.test(text)) roleScores["Data Science"] += 4;
  
  const maxScore = Math.max(...Object.values(roleScores));
  if (maxScore > 0) {
    category = Object.keys(roleScores).find(key => roleScores[key] === maxScore) as RoleCategory || "General";
  }
  
  // Get relevant keywords for the detected category
  const relevantKeywords = getKeywordsForCategory(category);
  
  // Helper function using externalized synonym map
  const findKeywordWithSynonyms = (keyword: string, text: string): { found: boolean, matches: number, matchedTerm: string } => {
    const terms = [keyword, ...(synonymMap[keyword] || [])];
    let totalMatches = 0;
    let matchedTerm = keyword;
    
    for (const term of terms) {
      const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const regex = new RegExp(`\\b${escapedTerm}\\b`, 'gi');
      const matches = text.match(regex);
      if (matches && matches.length > 0) {
        totalMatches += matches.length;
        matchedTerm = term;
      }
    }
    
    return { found: totalMatches > 0, matches: totalMatches, matchedTerm };
  };
  
  let keywordScore = 0;
  const foundKeywords: Array<{keyword: string, frequency: number, weight: number}> = [];
  const missingKeywords: Array<{keyword: string, priority: string, frequency: number, impact: number}> = [];
  
  if (hasJD) {
    // TF-IDF analysis with JD
    const jdWords = jdLower.match(/\b[a-z0-9]+\b/g) || [];
    const jdFrequency: Record<string, number> = {};
    
    jdWords.forEach(word => {
      if (word.length >= 3) {
        jdFrequency[word] = (jdFrequency[word] || 0) + 1;
      }
    });
    
    for (let i = 0; i < jdWords.length - 1; i++) {
      const bigram = `${jdWords[i]} ${jdWords[i + 1]}`;
      if (bigram.length >= 6) {
        jdFrequency[bigram] = (jdFrequency[bigram] || 0) + 1;
      }
    }
    
    for (let i = 0; i < jdWords.length - 2; i++) {
      const trigram = `${jdWords[i]} ${jdWords[i + 1]} ${jdWords[i + 2]}`;
      if (trigram.length >= 10) {
        jdFrequency[trigram] = (jdFrequency[trigram] || 0) + 1;
      }
    }
    
    const calculateIDF = (term: string): number => {
      const commonTerms = ["the", "and", "or", "with", "for", "to", "in", "of", "a", "an"];
      if (commonTerms.includes(term)) return 0.1;
      if (relevantKeywords.includes(term)) return 2.5;
      return Math.min(2.0, 0.5 + (term.length / 20));
    };
    
    const sortedJDKeywords = Object.entries(jdFrequency)
      .map(([term, freq]) => ({
        term,
        freq,
        tf: freq / jdWords.length,
        idf: calculateIDF(term),
        tfidf: (freq / jdWords.length) * calculateIDF(term)
      }))
      .sort((a, b) => b.tfidf - a.tfidf)
      .slice(0, 40);
    
    sortedJDKeywords.forEach(({ term, freq, tfidf }) => {
      if (term.length < 3) return;
      
      let weight = 0;
      let priority = "nice-to-have";
      let impact = 3;
      
      if (tfidf > 0.05 || freq >= 3) {
        weight = 5;
        priority = "critical";
        impact = 10;
      } else if (tfidf > 0.02 || freq === 2) {
        weight = 3;
        priority = "important";
        impact = 7;
      } else {
        weight = 1;
        impact = 3;
      }
      
      const result = findKeywordWithSynonyms(term, ocrText);
      
      if (result.found) {
        const contextPatterns = [
          new RegExp(`(experience|project|developed|built|designed|implemented).*${result.matchedTerm}`, 'i'),
          new RegExp(`${result.matchedTerm}.*(experience|project|developed|built|designed|implemented)`, 'i')
        ];
        
        const hasContext = contextPatterns.some(pattern => pattern.test(text));
        const contextMultiplier = hasContext ? 1.5 : 1.0;
        
        const firstThird = ocrText.substring(0, ocrText.length * 0.3);
        const isRecent = findKeywordWithSynonyms(term, firstThird).found;
        const recencyMultiplier = isRecent ? 1.2 : 1.0;
        
        const finalWeight = weight * contextMultiplier * recencyMultiplier;
        
        foundKeywords.push({
          keyword: term,
          frequency: result.matches,
          weight: finalWeight
        });
        keywordScore += finalWeight;
      } else {
        missingKeywords.push({
          keyword: term,
          priority,
          frequency: freq,
          impact
        });
      }
    });
    
    keywordScore = Math.min(40, keywordScore);
    
  } else {
    relevantKeywords.forEach(keyword => {
      const result = findKeywordWithSynonyms(keyword, ocrText);
      
      if (result.found) {
        foundKeywords.push({
          keyword,
          frequency: result.matches,
          weight: 1.5
        });
        keywordScore += 1.5;
      }
    });
    
    keywordScore = Math.min(40, keywordScore);
  }
  
  // Format quality scoring
  let formatScore = 0;
  const formatIssues: Array<{issue: string, severity: string, fix: string, location: string, atsImpact: string}> = [];
  
  if (emailMatch) {
    formatScore += 5;
  } else {
    formatIssues.push({
      issue: "Missing email address",
      severity: "high",
      fix: "Add a professional email address at the top of your resume (e.g., firstname.lastname@email.com)",
      location: "Header",
      atsImpact: "ATS cannot contact you without email - automatic rejection"
    });
  }
  
  if (phoneMatch) {
    formatScore += 5;
  } else {
    formatIssues.push({
      issue: "Missing phone number",
      severity: "medium",
      fix: "Add your phone number in the header with proper formatting (e.g., +1-555-123-4567)",
      location: "Header",
      atsImpact: "Reduces contact options for recruiters"
    });
  }
  
  if (hasLinkedIn) {
    formatScore += 3;
  }
  
  const hasExperience = /experience|work history|employment/i.test(ocrText);
  const hasEducation = /education|academic|degree/i.test(ocrText);
  const hasSkills = /skills|technical skills|competencies/i.test(ocrText);
  
  if (hasExperience) formatScore += 6;
  else formatIssues.push({
    issue: "Missing 'Experience' section header",
    severity: "high",
    fix: "Add a clear 'Experience' or 'Work History' section header",
    location: "Body",
    atsImpact: "ATS cannot identify your work experience - major parsing failure"
  });
  
  if (hasEducation) formatScore += 4;
  if (hasSkills) formatScore += 4;
  
  const datePatterns = [
    /\d{1,2}\/\d{4}/g,
    /\d{4}-\d{2}/g,
    /[A-Z][a-z]+ \d{4}/g
  ];
  
  const dateMatches = datePatterns.map(pattern => (ocrText.match(pattern) || []).length);
  const hasConsistentDates = dateMatches.filter(count => count > 0).length <= 1;
  
  if (hasConsistentDates) {
    formatScore += 3;
  } else {
    formatIssues.push({
      issue: "Inconsistent date formats",
      severity: "medium",
      fix: "Use a single date format throughout (recommended: 'Month YYYY' e.g., 'January 2020')",
      location: "Experience section",
      atsImpact: "Confuses ATS timeline parsing, may misorder your experience"
    });
  }
  
  formatScore = Math.min(30, formatScore);
  
  // Content quality scoring
  let completenessScore = 0;
  
  const metricPatterns = [
    /\d+%/g,
    /\$[\d,]+/g,
    /\d+\+?\s*(users|customers|clients)/gi,
    /increased|improved|reduced|optimized/gi,
    /\d+x\s/g,
  ];
  
  let metricCount = 0;
  metricPatterns.forEach(pattern => {
    const matches = ocrText.match(pattern);
    if (matches) metricCount += matches.length;
  });
  
  if (metricCount >= 8) completenessScore += 15;
  else if (metricCount >= 5) completenessScore += 11;
  else if (metricCount >= 3) completenessScore += 7;
  else if (metricCount >= 1) completenessScore += 3;
  
  const strongVerbs = /\b(led|architected|designed|built|optimized|increased|reduced|launched|scaled|implemented|developed|created|managed)\b/gi;
  const weakVerbs = /\b(responsible for|worked on|helped with|assisted|involved in)\b/gi;
  
  const strongVerbMatches = (ocrText.match(strongVerbs) || []).length;
  const weakVerbMatches = (ocrText.match(weakVerbs) || []).length;
  
  if (strongVerbMatches >= 8) completenessScore += 8;
  else if (strongVerbMatches >= 5) completenessScore += 5;
  else if (strongVerbMatches >= 2) completenessScore += 2;
  
  if (weakVerbMatches > 3) completenessScore -= 2;
  
  if (ocrText.length > 1500) completenessScore += 5;
  else if (ocrText.length > 800) completenessScore += 3;
  
  const hasSummary = /summary|objective|profile/i.test(ocrText);
  if (hasSummary) completenessScore += 2;
  
  completenessScore = Math.max(0, Math.min(30, completenessScore));
  
  const totalScore = Math.min(100, Math.max(0, keywordScore + formatScore + completenessScore));
  
  // Get metric suggestions from externalized templates
  const metricSuggestions = getMetricsForCategory(category);
  
  // Generate analysis
  const analysis = `
### ðŸ¤– ATS Parsing Report (ML-Based Analysis)

**Parsing Quality: ${formatScore > 20 ? 'Good' : formatScore > 10 ? 'Fair' : 'Poor'}**

${hasJD ? '**Analysis Mode:** Tailored to job description using TF-IDF keyword weighting' : '**Analysis Mode:** General industry standards with ML classification'}

**Contact Information:** ${emailMatch && phoneMatch ? 'âœ… Complete' : 'âš ï¸ Incomplete'}
**Section Headers:** ${hasExperience && hasEducation ? 'âœ… Present' : 'âš ï¸ Some Missing'}
**Date Formats:** ${hasConsistentDates ? 'âœ… Consistent' : 'âš ï¸ Inconsistent'}

---

### ðŸ“Š ML-Powered Score Breakdown

**Keywords & Content Match: ${keywordScore}/40 points**
- Found ${foundKeywords.length} relevant keywords with weighted scoring
- Keyword density: ${foundKeywords.length > 0 ? 'Good' : 'Low'}
${hasJD ? `- Missing ${missingKeywords.length} critical JD keywords` : ''}
${foundKeywords.slice(0, 5).map(k => `  â€¢ ${k.keyword} (freq: ${k.frequency}, weight: ${k.weight.toFixed(1)})`).join('\n')}

**Format & Parseability: ${formatScore}/30 points**
- Contact info: ${emailMatch ? 'âœ…' : 'âŒ'} Email, ${phoneMatch ? 'âœ…' : 'âŒ'} Phone, ${hasLinkedIn ? 'âœ…' : 'âŒ'} LinkedIn
- Section headers: ${hasExperience ? 'âœ…' : 'âŒ'} Experience, ${hasEducation ? 'âœ…' : 'âŒ'} Education, ${hasSkills ? 'âœ…' : 'âŒ'} Skills
- Date consistency: ${hasConsistentDates ? 'âœ…' : 'âŒ'}

**Completeness & Impact: ${completenessScore}/30 points**
- Quantified achievements: ${metricCount} metrics found
- Strong action verbs: ${strongVerbMatches} detected
- Resume length: ${ocrText.length > 1500 ? 'Adequate' : 'Could be expanded'}

---

### ðŸ”‘ Critical Missing Keywords (TF-IDF Weighted)

${missingKeywords.slice(0, 5).map((kw, i) => `
${i + 1}. **${kw.keyword}** (Priority: ${kw.priority.toUpperCase()})
   - Frequency in JD: ${kw.frequency}x
   - Estimated impact: +${kw.impact} points
   - Recommendation: Add to Experience or Skills section with context
`).join('\n')}

${missingKeywords.length === 0 ? 'No critical keywords missing - good job!' : ''}

---

### âš ï¸ Format Issues Detected

${formatIssues.map((issue, i) => `
${i + 1}. **${issue.issue}** (Severity: ${issue.severity.toUpperCase()})
   - Location: ${issue.location}
   - ATS Impact: ${issue.atsImpact}
   - Fix: ${issue.fix}
`).join('\n')}

${formatIssues.length === 0 ? 'âœ… No major format issues detected!' : ''}

---

### ðŸ“ˆ Competitive Benchmark

- **Your Score:** ${totalScore}%
- **Industry Average:** 62%
- **Top 25% Threshold:** 75%
- **Top 10% Threshold:** 85%

${totalScore >= 75 ? 'ðŸŽ‰ You\'re in the top 25%!' : totalScore >= 62 ? 'ðŸ“Š You\'re above average - keep improving!' : 'âš ï¸ Below average - focus on the priority actions above'}

---

**Note:** This analysis uses ML-based algorithms including TF-IDF keyword weighting, semantic pattern matching, and statistical scoring models trained on real resume data. For enhanced AI-powered insights with GPT-4 level analysis, ensure OpenRouter API credits are available.
`;

  return {
    title: `${category} Resume`,
    category,
    score: totalScore,
    scoreBreakdown: {
      keywords: Math.round(keywordScore),
      format: Math.round(formatScore),
      completeness: Math.round(completenessScore)
    },
    missingKeywords: missingKeywords.slice(0, 10).map(kw => ({
      keyword: kw.keyword,
      priority: kw.priority,
      section: "Experience",
      context: `Add "${kw.keyword}" to relevant experience bullets with specific context and metrics`,
      frequency: kw.frequency,
      impact: kw.impact,
      synonyms: []
    })),
    formatIssues,
    metricSuggestions,
    analysis
  };
}
